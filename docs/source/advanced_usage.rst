Advanced Usage
==============

__ usage.html

In this page we give an overview of the most advanced features available in P4-Utils. In the
following paragraphs, we will explore some programmatic ways to configure the control plane 
and to schedule tasks on the nodes of the network.

To get started, let us consider again the example already presented in the `usage section`__.
Let us assume, that we already followed the instructions to create the network and we are 
now able to start it. We need to configure the switch ``s1`` to make it able to perform
L2 forwarding.

.. image:: _images/l2_topology.png
   :align: center

.. Important::
   __ https://github.com/nsg-ethz/p4-learning

   For more examples and use cases, we recommend to check out the repository `P4-Learning`__. It
   is a collections of working examples and exercises that are very helpful to start programming
   with P4.

Control Plane Configuration
---------------------------

__ usage.html#thrift-client

In the following sections, we explore two alternatives to the *Thrift* command-line
client `method`__ to configure the control plane. 

Thrift API
++++++++++

The *Thrift API* can be used with every P4 switch and it is based on the code of the
*Thrift* command-line client. In fact, it provides the same methods to control the switch.
The implementation of the *Thrift API* relies on 
:py:class:`~p4utils.utils.sswitch_thrift_API.SimpleSwitchThriftAPI` and its parent 
:py:class:`~p4utils.utils.thrift_API.ThriftAPI`. Please check them out to learn more
about the available control plane methods.

To get started, we create a new Python script called ``controller.py`` and we import
the module needed to configure the P4 switch::

    from p4utils.utils.sswitch_thrift_API import SimpleSwitchThriftAPI

__ usage.html#thrift-client

We also need to esablish a connection with the server running on the switch. We know
that the *Thrift* server of ``s1`` is listening on ``127.0.0.1:9090`` (see `here`__), so we can 
connect using::

    controller = SimpleSwitchThriftAPI(9090)

.. Warning::
   :py:class:`~p4utils.utils.sswitch_thrift_API.SimpleSwitchThriftAPI` assumes by default
   that the IP address of the *Thrift* server is ``127.0.0.1``.

Now, we can use the controller to set up our forwarding rules. We can use the 
method :py:meth:`~p4utils.utils.thrift_API.ThriftAPI.table_add()`::

    controller.table_add('dmac', 'forward', ['00:00:0a:00:00:01'], ['1'])
    controller.table_add('dmac', 'forward', ['00:00:0a:00:00:02'], ['2'])
    controller.table_add('dmac', 'forward', ['00:00:0a:00:00:03'], ['3'])
    controller.table_add('dmac', 'forward', ['00:00:0a:00:00:04'], ['4'])

Now, after the network starts, we can run the controller script to populate the
forwarding table of ``s1``::

    python3 controller.py

P4Runtime API
+++++++++++++
__ https://github.com/p4lang/behavioral-model

The *P4Runtime API* is implemented by
:py:class:`~p4utils.utils.sswitch_p4runtime_API.SimpleSwitchP4RuntimeAPI`.
Please check it out to learn more about the available control plane methods. Moreover,
consider that the *P4Runtime API* can only be used with P4Runtime capable switches:
not all the binaries provided by the `behavioral-model`__ implement this feature. 
As a consequence, only :py:class:`~p4utils.mininetlib.node.P4RuntimeSwitch` supports 
P4Runtime, whereas :py:class:`~p4utils.mininetlib.node.P4Switch` does not.

__ #enabling-p4runtime-with-python
__ #enabling-p4runtime-with-json

For this reason, we provide a quick guide on how to enable P4Runtime in your network using the
`Python script`__ or the `JSON file`__.

.. Warning::
   __ https://github.com/p4lang/behavioral-model

   The `behavioral-model`__ must be build with the P4Runtime dependencies in order to 
   make it work. Otherwise, only non-P4Runtime targets will be available.

Assuming that we have correctly enabled P4Runtime, we can write our Python P4Runtime
controller (called ``controller.py``) for the switch ``s1``::

    from p4utils.utils.sswitch_p4runtime_API import SimpleSwitchP4RuntimeAPI

    controller = SimpleSwitchP4RuntimeAPI(device_id=1, grpc_port=9559,
                                          p4rt_path='l2_forwarding_p4rt.txt',
                                          json_path='l2_forwarding.json')

.. Important::
   __ #enabling-p4runtime-with-python
   __ #enabling-p4runtime-with-json

   Both the P4Info file ``l2_forwarding_p4rt.txt`` and the P4 compiled JSON file 
   ``l2_forwarding.json`` are generated by the P4 compiler. In order to enable the P4Info file
   generation, please check the P4Runtime guides for `Python`__ and `JSON`__.

.. Warning::
   - The ``device_id`` can be explicitly assigned to the switches in the network configuration.
     If the ``device_id`` is not specified for any switch in the network, then the alphabetic
     order is used for the assignment and the first switch will get ``1``.
   - The ``grpc_port`` can be explicitly assigned to the P4Runtime switches in the 
     network configuration. If the ``grpc_port`` is not specified for any P4Runtime switch in
     the network, then the alphabetic order is used for the assignment and the first P4Runtime 
     switch will get ``9559``.

Now, we can use the controller to set up our forwarding rules. We can use the 
method :py:meth:`~p4utils.utils.sswitch_p4runtime_API.SimpleSwitchP4RuntimeAPI.table_add()`::

    controller.table_add('dmac', 'forward', ['00:00:0a:00:00:01'], ['1'])
    controller.table_add('dmac', 'forward', ['00:00:0a:00:00:02'], ['2'])
    controller.table_add('dmac', 'forward', ['00:00:0a:00:00:03'], ['3'])
    controller.table_add('dmac', 'forward', ['00:00:0a:00:00:04'], ['4'])

Now, after the network starts, we can run the controller script to populate the
forwarding table of ``s1``::

    python3 controller.py

Enabling P4Runtime with Python
______________________________

Considering our simple example, the P4 compiler has to know that we are using a P4Runtime switch
to generate the P4Info file needed to connect to the P4Runtime server of the switch.
::

    net.setCompiler(p4rt=True)

Afterwards, we need also to specify that we are using P4Runtime switches. In the
Python network configuration script, this can be done by writing::

    net.addP4RuntimeSwtich('s1')

Enabling P4Runtime with JSON
____________________________

For what concerns the JSON confinguration files, the P4 compiler can generate the P4Info if
one specifies it with the ``compiler_module`` option. Moreover, one can set the default 
type of P4 switches with the ``switch_node`` option. In this way, we can make every switch a 
:py:class:`~p4utils.mininetlib.node.P4RuntimeSwitch`.

After having applied all the aforementioned settings to the JSON network configuration file of
our simple example, it looks like this::

  {
    "p4_src": "l2_forwarding.p4",
    "cli": true,
    "pcap_dump": true,
    "enable_log": true,
    "compiler_module":
    {
      "options":
      {
        "p4rt": true
      }
    },
    "switch_node":
    {
      "module_name": "p4utils.mininetlib.node",
      "object_name": "P4RuntimeSwitch"
    },
    "topology": {
      "assignment_strategy": "l2",
      "default": {
        "bw": 10
      }, 
      "links": [["h1", "s1"], ["h2", "s1"], ["h3", "s1"], ["h4", "s1"]],
      "hosts": {
        "h1": {
        },
        "h2": {
        }
        ,
        "h3": {
        }
        ,
        "h4": {
        }
      },
      "switches": {
        "s1": {
        }
      }
    }
  }

Topology Database
-----------------



Task Scheduler
--------------