version:
  version: 1.0.1
  run_id: "346445b61372940a"
  target: Tofino
phv ingress:
  hdr.ethernet.dst_addr.0-31: W0
  hdr.ethernet.dst_addr.32-47: H1
  hdr.ethernet.src_addr.0-31: W1
  hdr.ethernet.src_addr.32-47: H2
  hdr.ethernet.ether_type: TH4
  hdr.ipv4.version: TW1(28..31)
  hdr.ipv4.ihl: TW1(24..27)
  hdr.ipv4.dscp: TW1(18..23)
  hdr.ipv4.ecn: TW1(16..17)
  hdr.ipv4.totalLen: TW1(0..15)
  hdr.ipv4.identification: TW2(16..31)
  hdr.ipv4.flags: TW2(13..15)
  hdr.ipv4.fragOffset: TW2(0..12)
  hdr.ipv4.ttl: B0
  hdr.ipv4.protocol: B2
  hdr.ipv4.hdrChecksum: TH5
  hdr.ipv4.srcAddr: W4
  hdr.ipv4.dstAddr: W3
  hdr.tcp.srcPort: W2(16..31)
  hdr.tcp.dstPort: W2(0..15)
  hdr.tcp.seqNo.0-15: TH2
  hdr.tcp.seqNo.16-31: TH3
  hdr.tcp.ackNo.0-15: TH0
  hdr.tcp.ackNo.16-31: TH1
  hdr.tcp.dataOffset: TW0(28..31)
  hdr.tcp.res: TW0(24..27)
  hdr.tcp.cwr: TW0(23)
  hdr.tcp.ece: TW0(22)
  hdr.tcp.urg: TW0(21)
  hdr.tcp.ack: TW0(20)
  hdr.tcp.psh: TW0(19)
  hdr.tcp.rst: TW0(18)
  hdr.tcp.syn: TW0(17)
  hdr.tcp.fin: TW0(16)
  hdr.tcp.window: TW0(0..15)
  hdr.tcp.checksum: TW3(16..31)
  hdr.tcp.urgentPtr: TW3(0..15)
  output_hash_0.0-7: B4
  output_hash_0.8-11: B1(3..6)
  counter.0-7: B5
  counter.8-11: B3(3..6)
  counter_0: H3(0..11)
  ig_intr_md_for_dprsr.drop_ctl: B1(0..2)
  ig_intr_md_for_tm.ucast_egress_port: H0(0..8)
  hdr.ethernet.$valid: B3(0)
  hdr.ipv4.$valid: B3(1)
  hdr.tcp.$valid: B3(2)
  context_json:
    B0:
    - { name : hdr.ipv4.ttl, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    B1:
    - { name : output_hash_0, live_start : 0, live_end : 1, mutually_exclusive_with: [  ] }
    - { name : ig_intr_md_for_dprsr.drop_ctl, live_start : 0, live_end : deparser, mutually_exclusive_with: [  ] }
    B2:
    - { name : hdr.ipv4.protocol, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    B3:
    - { name : counter, live_start : 0, live_end : 1, mutually_exclusive_with: [  ] }
    - { name : hdr.ethernet.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.ipv4.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.tcp.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    B4:
    - { name : output_hash_0, live_start : 0, live_end : 1, mutually_exclusive_with: [  ] }
    B5:
    - { name : counter, live_start : 0, live_end : 1, mutually_exclusive_with: [  ] }
    H0:
    - { name : ig_intr_md_for_tm.ucast_egress_port, live_start : 3, live_end : deparser, mutually_exclusive_with: [  ] }
    H1:
    - { name : hdr.ethernet.dst_addr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    H2:
    - { name : hdr.ethernet.src_addr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    H3:
    - { name : counter_0, live_start : 1, live_end : 2, mutually_exclusive_with: [  ] }
    W0:
    - { name : hdr.ethernet.dst_addr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W1:
    - { name : hdr.ethernet.src_addr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W2:
    - { name : hdr.tcp.srcPort, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.tcp.dstPort, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W3:
    - { name : hdr.ipv4.dstAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W4:
    - { name : hdr.ipv4.srcAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
phv egress:
  eg_intr_md.egress_port: H16(0..8)
  context_json:
    H16:
    - { name : eg_intr_md.egress_port, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
parser ingress:
  start: $entry_point
  init_zero: [ B4, B1, B5, B3, H3 ]
  bitwise_or: [ B3 ]
  hdr_len_adj: 16
  states:
    $entry_point:
      *:
        load: { half : 28..29 }
        buf_req: 30
        next: start
    start:
      match: [ half ]
      0x0800:
        16..17: H1  # ingress::hdr.ethernet.dst_addr[47:32].32-47
        18..21: W0  # ingress::hdr.ethernet.dst_addr[31:0].0-31
        22..23: H2  # ingress::hdr.ethernet.src_addr[47:32].32-47
        24..27: W1  # ingress::hdr.ethernet.src_addr[31:0].0-31
        28..29: TH4  # ingress::hdr.ethernet.ether_type
        B3: 1  # value 1 -> B3 bit[0]: ingress::hdr.ethernet.$valid
        shift: 30
        buf_req: 30
        next: start.$oob_stall_0
      0x****:
        16..17: H1  # ingress::hdr.ethernet.dst_addr[47:32].32-47
        18..21: W0  # ingress::hdr.ethernet.dst_addr[31:0].0-31
        22..23: H2  # ingress::hdr.ethernet.src_addr[47:32].32-47
        24..27: W1  # ingress::hdr.ethernet.src_addr[31:0].0-31
        28..29: TH4  # ingress::hdr.ethernet.ether_type
        B3: 1  # value 1 -> B3 bit[0]: ingress::hdr.ethernet.$valid
        shift: 30
        buf_req: 30
        next: end
    start.$oob_stall_0:
      *:
        load: { byte1 : 9 }
        buf_req: 10
        next: parse_ipv4
    parse_ipv4:
      match: [ byte1 ]
      0x06:
        0..3: TW1
            # - bit[0..3] -> TW1 bit[31..28]: ingress::hdr.ipv4.version
            # - bit[4..7] -> TW1 bit[27..24]: ingress::hdr.ipv4.ihl
            # - bit[8..13] -> TW1 bit[23..18]: ingress::hdr.ipv4.dscp
            # - bit[14..15] -> TW1 bit[17..16]: ingress::hdr.ipv4.ecn
            # - bit[16..31] -> TW1 bit[15..0]: ingress::hdr.ipv4.totalLen
        4..7: TW2
            # - bit[32..47] -> TW2 bit[31..16]: ingress::hdr.ipv4.identification
            # - bit[48..50] -> TW2 bit[15..13]: ingress::hdr.ipv4.flags
            # - bit[51..63] -> TW2 bit[12..0]: ingress::hdr.ipv4.fragOffset
        8: B0  # ingress::hdr.ipv4.ttl
        9: B2  # ingress::hdr.ipv4.protocol
        10..11: TH5  # ingress::hdr.ipv4.hdrChecksum
        12..15: W4  # ingress::hdr.ipv4.srcAddr
        16..19: W3  # ingress::hdr.ipv4.dstAddr
        B3: 2  # value 1 -> B3 bit[1]: ingress::hdr.ipv4.$valid
        shift: 20
        buf_req: 20
        next: parse_tcp
      0x**:
        0..3: TW1
            # - bit[0..3] -> TW1 bit[31..28]: ingress::hdr.ipv4.version
            # - bit[4..7] -> TW1 bit[27..24]: ingress::hdr.ipv4.ihl
            # - bit[8..13] -> TW1 bit[23..18]: ingress::hdr.ipv4.dscp
            # - bit[14..15] -> TW1 bit[17..16]: ingress::hdr.ipv4.ecn
            # - bit[16..31] -> TW1 bit[15..0]: ingress::hdr.ipv4.totalLen
        4..7: TW2
            # - bit[32..47] -> TW2 bit[31..16]: ingress::hdr.ipv4.identification
            # - bit[48..50] -> TW2 bit[15..13]: ingress::hdr.ipv4.flags
            # - bit[51..63] -> TW2 bit[12..0]: ingress::hdr.ipv4.fragOffset
        8: B0  # ingress::hdr.ipv4.ttl
        9: B2  # ingress::hdr.ipv4.protocol
        10..11: TH5  # ingress::hdr.ipv4.hdrChecksum
        12..15: W4  # ingress::hdr.ipv4.srcAddr
        16..19: W3  # ingress::hdr.ipv4.dstAddr
        B3: 2  # value 1 -> B3 bit[1]: ingress::hdr.ipv4.$valid
        shift: 20
        buf_req: 20
        next: end
    parse_tcp:
      *:
        0..3: W2
            # - bit[0..15] -> W2 bit[31..16]: ingress::hdr.tcp.srcPort
            # - bit[16..31] -> W2 bit[15..0]: ingress::hdr.tcp.dstPort
        4..5: TH3  # ingress::hdr.tcp.seqNo[31:16].16-31
        6..7: TH2  # ingress::hdr.tcp.seqNo[15:0].0-15
        8..9: TH1  # ingress::hdr.tcp.ackNo[31:16].16-31
        10..11: TH0  # ingress::hdr.tcp.ackNo[15:0].0-15
        12..15: TW0
            # - bit[96..99] -> TW0 bit[31..28]: ingress::hdr.tcp.dataOffset
            # - bit[100..103] -> TW0 bit[27..24]: ingress::hdr.tcp.res
            # - bit[104] -> TW0 bit[23]: ingress::hdr.tcp.cwr
            # - bit[105] -> TW0 bit[22]: ingress::hdr.tcp.ece
            # - bit[106] -> TW0 bit[21]: ingress::hdr.tcp.urg
            # - bit[107] -> TW0 bit[20]: ingress::hdr.tcp.ack
            # - bit[108] -> TW0 bit[19]: ingress::hdr.tcp.psh
            # - bit[109] -> TW0 bit[18]: ingress::hdr.tcp.rst
            # - bit[110] -> TW0 bit[17]: ingress::hdr.tcp.syn
            # - bit[111] -> TW0 bit[16]: ingress::hdr.tcp.fin
            # - bit[112..127] -> TW0 bit[15..0]: ingress::hdr.tcp.window
        16..19: TW3
            # - bit[128..143] -> TW3 bit[31..16]: ingress::hdr.tcp.checksum
            # - bit[144..159] -> TW3 bit[15..0]: ingress::hdr.tcp.urgentPtr
        B3: 4  # value 1 -> B3 bit[2]: ingress::hdr.tcp.$valid
        shift: 20
        buf_req: 20
        next: end
deparser ingress:
  dictionary:
    H1: B3(0)  # ingress::hdr.ethernet.dst_addr.32-47 if ingress::hdr.ethernet.$valid
    W0: B3(0)  # ingress::hdr.ethernet.dst_addr.0-31 if ingress::hdr.ethernet.$valid
    H2: B3(0)  # ingress::hdr.ethernet.src_addr.32-47 if ingress::hdr.ethernet.$valid
    W1: B3(0)  # ingress::hdr.ethernet.src_addr.0-31 if ingress::hdr.ethernet.$valid
    TH4: B3(0)  # ingress::hdr.ethernet.ether_type if ingress::hdr.ethernet.$valid
    TW1: B3(1)
        # - bit[31..28]: ingress::hdr.ipv4.version if ingress::hdr.ipv4.$valid
        # - bit[27..24]: ingress::hdr.ipv4.ihl if ingress::hdr.ipv4.$valid
        # - bit[23..18]: ingress::hdr.ipv4.dscp if ingress::hdr.ipv4.$valid
        # - bit[17..16]: ingress::hdr.ipv4.ecn if ingress::hdr.ipv4.$valid
        # - bit[15..0]: ingress::hdr.ipv4.totalLen if ingress::hdr.ipv4.$valid
    TW2: B3(1)
        # - bit[31..16]: ingress::hdr.ipv4.identification if ingress::hdr.ipv4.$valid
        # - bit[15..13]: ingress::hdr.ipv4.flags if ingress::hdr.ipv4.$valid
        # - bit[12..0]: ingress::hdr.ipv4.fragOffset if ingress::hdr.ipv4.$valid
    B0: B3(1)  # ingress::hdr.ipv4.ttl if ingress::hdr.ipv4.$valid
    B2: B3(1)  # ingress::hdr.ipv4.protocol if ingress::hdr.ipv4.$valid
    full_checksum 0: B3(1)  # ingress::hdr.ipv4.$valid
    W4: B3(1)  # ingress::hdr.ipv4.srcAddr if ingress::hdr.ipv4.$valid
    W3: B3(1)  # ingress::hdr.ipv4.dstAddr if ingress::hdr.ipv4.$valid
    W2: B3(2)
        # - bit[31..16]: ingress::hdr.tcp.srcPort if ingress::hdr.tcp.$valid
        # - bit[15..0]: ingress::hdr.tcp.dstPort if ingress::hdr.tcp.$valid
    TH3: B3(2)  # ingress::hdr.tcp.seqNo.16-31 if ingress::hdr.tcp.$valid
    TH2: B3(2)  # ingress::hdr.tcp.seqNo.0-15 if ingress::hdr.tcp.$valid
    TH1: B3(2)  # ingress::hdr.tcp.ackNo.16-31 if ingress::hdr.tcp.$valid
    TH0: B3(2)  # ingress::hdr.tcp.ackNo.0-15 if ingress::hdr.tcp.$valid
    TW0: B3(2)
        # - bit[31..28]: ingress::hdr.tcp.dataOffset if ingress::hdr.tcp.$valid
        # - bit[27..24]: ingress::hdr.tcp.res if ingress::hdr.tcp.$valid
        # - bit[23]: ingress::hdr.tcp.cwr if ingress::hdr.tcp.$valid
        # - bit[22]: ingress::hdr.tcp.ece if ingress::hdr.tcp.$valid
        # - bit[21]: ingress::hdr.tcp.urg if ingress::hdr.tcp.$valid
        # - bit[20]: ingress::hdr.tcp.ack if ingress::hdr.tcp.$valid
        # - bit[19]: ingress::hdr.tcp.psh if ingress::hdr.tcp.$valid
        # - bit[18]: ingress::hdr.tcp.rst if ingress::hdr.tcp.$valid
        # - bit[17]: ingress::hdr.tcp.syn if ingress::hdr.tcp.$valid
        # - bit[16]: ingress::hdr.tcp.fin if ingress::hdr.tcp.$valid
        # - bit[15..0]: ingress::hdr.tcp.window if ingress::hdr.tcp.$valid
    TW3: B3(2)
        # - bit[31..16]: ingress::hdr.tcp.checksum if ingress::hdr.tcp.$valid
        # - bit[15..0]: ingress::hdr.tcp.urgentPtr if ingress::hdr.tcp.$valid
  partial_checksum 0: 
    - TW1: { }
        # - bit[31..28]: ingress::hdr.ipv4.version
        # - bit[27..24]: ingress::hdr.ipv4.ihl
        # - bit[23..18]: ingress::hdr.ipv4.dscp
        # - bit[17..16]: ingress::hdr.ipv4.ecn
        # - bit[15..0]: ingress::hdr.ipv4.totalLen
    - TW2: { }
        # - bit[31..16]: ingress::hdr.ipv4.identification
        # - bit[15..13]: ingress::hdr.ipv4.flags
        # - bit[12..0]: ingress::hdr.ipv4.fragOffset
    - B0: { swap: 1 }  # ingress::hdr.ipv4.ttl
    - B2: { }  # ingress::hdr.ipv4.protocol
    - W4: { }  # ingress::hdr.ipv4.srcAddr
    - W3: { }  # ingress::hdr.ipv4.dstAddr
  full_checksum 0: 
    - partial_checksum 0: { }
  egress_unicast_port: H0(0..8)  # bit[8..0]: ingress::ig_intr_md_for_tm.ucast_egress_port
  drop_ctl: B1(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.drop_ctl
parser egress:
  start: $entry_point.start
  hdr_len_adj: 27
  meta_opt: 8191
  states:
    $entry_point.start:
      *:
        0..1: H16  # bit[7..15] -> H16 bit[8..0]: egress::eg_intr_md.egress_port
        intr_md: 9
        shift: 27
        buf_req: 27
        next: end
deparser egress:
  dictionary: {}
  egress_unicast_port: H16(0..8)  # bit[8..0]: egress::eg_intr_md.egress_port
stage 0 ingress:
  phase0_match IngressParser.$PORT_METADATA:
    p4:
      name: IngressParser.$PORT_METADATA
      size: 288
      preferred_match_type: exact
      match_type: exact
    size: 288
    p4_param_order:
      ig_intr_md.ingress_port: { type: exact, size: 9 }
    format: {ig_intr_md: 0..63}
    constant_value: 0
    actions:
      set_port_metadata:
      - handle: 0x20000000
      - p4_param_order: { ig_intr_md: 64 } 
  ternary_match tbl_drop_0 0:
    p4: { name: tbl_drop_0, hidden: true }
    gateway:
      name: cond-5
      input_xbar:
        exact group 0: { 1: hdr.ipv4.$valid }
      row: 0
      bus: 1
      unit: 1
      match: { 1: hdr.ipv4.$valid }
      0b******1:  tbl_heavy_hitter200
      miss: run_table
      condition: 
        expression: "(hdr.ipv4.$valid == 1)"
        true:  tbl_heavy_hitter200
        false:  tbl_drop_0
    hit: [  END ]
    miss:  END
    indirect: tbl_drop_0$tind
  ternary_indirect tbl_drop_0$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: tbl_drop_0$tind(action, $DEFAULT)
    actions:
      Ingress.drop(1, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000006
      - next_table: 0
      - set ig_intr_md_for_dprsr.drop_ctl, 1
    default_action: Ingress.drop
  hash_action tbl_heavy_hitter200 1:
    p4: { name: tbl_heavy_hitter200, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      0: { hash: 0, mask: 0xff0f, shift: 0 }
      1: { hash: 0, mask: 0xfff, shift: 4 }
    input_xbar:
      exact group 0: { 8: hdr.tcp.dstPort(8..15), 16: hdr.tcp.srcPort, 32: hdr.tcp.dstPort(0..7), 40: hdr.ipv4.dstAddr(8..31), 64: hdr.ipv4.dstAddr(0..7), 72: hdr.ipv4.srcAddr(8..31), 96: hdr.ipv4.srcAddr(0..7), 104: hdr.ipv4.protocol }
      hash 0:
        0..3: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 104, { 8: hdr.tcp.dstPort(0..7), 16: hdr.tcp.dstPort(8..15), 24: hdr.tcp.srcPort, 48: hdr.ipv4.dstAddr(8..31) }, { })), 8..11)
      hash 1:
        0..3: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 104, { 0: hdr.ipv4.protocol, 40: hdr.ipv4.dstAddr(0..7), 72: hdr.ipv4.srcAddr(0..7), 80: hdr.ipv4.srcAddr(8..31) }, { })), 8..11)
      hash group 0:
        table: [0, 1]
        seed: 0x6
      exact group 0: { 8: hdr.tcp.dstPort(8..15), 16: hdr.tcp.srcPort, 32: hdr.tcp.dstPort(0..7), 40: hdr.ipv4.dstAddr(8..31), 64: hdr.ipv4.dstAddr(0..7), 72: hdr.ipv4.srcAddr(8..31), 96: hdr.ipv4.srcAddr(0..7), 104: hdr.ipv4.protocol }
      hash 0:
        8..15: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 104, { 8: hdr.tcp.dstPort(0..7), 16: hdr.tcp.dstPort(8..15), 24: hdr.tcp.srcPort, 48: hdr.ipv4.dstAddr(8..31) }, { })), 0..7)
      hash 1:
        8..15: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 104, { 0: hdr.ipv4.protocol, 40: hdr.ipv4.dstAddr(0..7), 72: hdr.ipv4.srcAddr(0..7), 80: hdr.ipv4.srcAddr(8..31) }, { })), 0..7)
      hash group 0:
        table: [0, 1]
        seed: 0x8200
      exact group 0: { 8: hdr.tcp.dstPort(8..15), 16: hdr.tcp.srcPort, 32: hdr.tcp.dstPort(0..7), 40: hdr.ipv4.dstAddr(8..31), 64: hdr.ipv4.dstAddr(0..7), 72: hdr.ipv4.srcAddr(8..31), 96: hdr.ipv4.srcAddr(0..7), 104: hdr.ipv4.protocol }
      hash 0:
        16..27: slice(stripe(crc_rev(0xc002, 0x0, 0x0, 104, { 8: hdr.tcp.dstPort(0..7), 16: hdr.tcp.dstPort(8..15), 24: hdr.tcp.srcPort, 48: hdr.ipv4.dstAddr(8..31) }, { })), 0..11)
      hash 1:
        16..27: slice(stripe(crc_rev(0xc002, 0x0, 0x0, 104, { 0: hdr.ipv4.protocol, 40: hdr.ipv4.dstAddr(0..7), 72: hdr.ipv4.srcAddr(0..7), 80: hdr.ipv4.srcAddr(8..31) }, { })), 0..11)
      hash group 0:
        table: [0, 1]
        seed: 0x0
    gateway:
      name: cond-6
      input_xbar:
        exact group 1: { 2: hdr.tcp.$valid }
      row: 0
      bus: 0
      unit: 0
      payload_row: 0
      payload_unit: 0
      payload: 0x7
      format: { action: 0..0, meter_pfe: 1..1, meter_type: 2..4 }
      match: { 2: hdr.tcp.$valid }
      0b*****1:  tbl_heavy_hitter213
      miss: run_table
      condition: 
        expression: "(hdr.tcp.$valid == 1)"
        true:  tbl_heavy_hitter213
        false:  ipv4_lpm_0
    next:  ipv4_lpm_0
    action_bus: { 16 : hash_dist(0, 0..7, lo), 17 : hash_dist(0, 8..15, lo), 0 : tbl_heavy_hitter200$salu.Ingress.bloom_filter_1(0..7), 1 : tbl_heavy_hitter200$salu.Ingress.bloom_filter_1(8..15) }
    stateful: tbl_heavy_hitter200$salu.Ingress.bloom_filter_1(hash_dist 1, meter_pfe, meter_type)
    instruction: tbl_heavy_hitter200(action, $DEFAULT)
    actions:
      heavy_hitter200(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000001
      - next_table: 0
      - set counter.0-7, tbl_heavy_hitter200$salu.Ingress.bloom_filter_1(0..7)
      - set counter.8-11, tbl_heavy_hitter200$salu.Ingress.bloom_filter_1(8..11)
      - set B1(3..6), hash_dist(0, 0..3)
      - set B4, hash_dist(0, 8..15)
      - tbl_heavy_hitter200$salu.Ingress.bloom_filter_1(update_bloom, $hash_dist)
    default_action: heavy_hitter200
  stateful tbl_heavy_hitter200$salu.Ingress.bloom_filter_1:
    p4: { name: Ingress.bloom_filter_1, size: 4096 }
    row: 15
    logical_bus: S
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    home_row: 15
    format: { lo: 16 }
    actions:
      update_bloom:
      - add lo, lo, 1
      - output alu_lo
stage 1 ingress:
  dependency: match
  hash_action tbl_heavy_hitter213 0:
    p4: { name: tbl_heavy_hitter213, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      0: { hash: 0, mask: 0xfff, shift: 4 }
    input_xbar:
      exact group 0: { 3: output_hash_0.8-11, 8: output_hash_0.0-7 }
      hash 0:
        0..7: output_hash_0.0-7
        8..11: output_hash_0.8-11
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: tbl_heavy_hitter213-gateway
      row: 0
      bus: 0
      unit: 1
      0x0:  cond-7
      miss:  cond-7
      condition: 
        expression: "true(always hit)"
        true:  cond-7
        false:  cond-7
    next: []
    action_bus: { 32..33 : tbl_heavy_hitter213$salu.Ingress.bloom_filter_2(0..15) }
    stateful: tbl_heavy_hitter213$salu.Ingress.bloom_filter_2(hash_dist 0, $DEFAULT, $DEFAULT)
    instruction: tbl_heavy_hitter213($DEFAULT, $DEFAULT)
    actions:
      heavy_hitter213(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000002
      - next_table: 0
      - set counter_0, tbl_heavy_hitter213$salu.Ingress.bloom_filter_2(0..11)
      - tbl_heavy_hitter213$salu.Ingress.bloom_filter_2(update_bloom_0, $hash_dist)
    default_action: heavy_hitter213
  stateful tbl_heavy_hitter213$salu.Ingress.bloom_filter_2:
    p4: { name: Ingress.bloom_filter_2, size: 4096 }
    row: 15
    logical_bus: S
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    home_row: 15
    format: { lo: 16 }
    actions:
      update_bloom_0:
      - add lo, lo, 1
      - output alu_lo
  gateway cond-7 1:
    name: cond-7
    input_xbar:
      exact group 0: { 67: counter.8-11, 72: counter.0-7 }
      hash 1:
        40..43: counter.8-11
        44..47: counter.0-7(4..7)
        48..51: counter.0-7(0..3)
      hash group 1:
        table: [1]
        seed: 0x0
    row: 0
    bus: 0
    unit: 0
    match: { 32: counter.8-11, 36: counter.0-7(4..7), 40: counter.0-7(0..3) }
    range: 4
    ? [ 0xfff0, * ] :  tbl_drop
    ? [ 0x8000, 0x8, * ] :  tbl_drop
    ? [ 0xfe00, 0x4000, 0x8, * ] :  tbl_drop
    miss:  ipv4_lpm_0
    condition: 
      expression: "(counter > 1000)"
      true:  tbl_drop
      false:  ipv4_lpm_0
stage 2 ingress:
  dependency: match
  ternary_match tbl_drop 0:
    p4: { name: tbl_drop, hidden: true }
    gateway:
      name: cond-8
      input_xbar:
        exact group 0: { 0: counter_0 }
        hash 0:
          40..43: counter_0(8..11)
          44..47: counter_0(4..7)
          48..51: counter_0(0..3)
        hash group 0:
          table: [0]
          seed: 0x0
      row: 0
      bus: 0
      unit: 0
      match: { 32: counter_0(8..11), 36: counter_0(4..7), 40: counter_0(0..3) }
      range: 4
      ? [ 0xfff0, * ] : run_table
      ? [ 0x8000, 0x8, * ] : run_table
      ? [ 0xfe00, 0x4000, 0x8, * ] : run_table
      miss:  ipv4_lpm_0
      condition: 
        expression: "(counter_0 > 1000)"
        true:  tbl_drop
        false:  ipv4_lpm_0
    hit: [  ipv4_lpm_0 ]
    miss:  ipv4_lpm_0
    indirect: tbl_drop$tind
  ternary_indirect tbl_drop$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: tbl_drop$tind(action, $DEFAULT)
    actions:
      Ingress.drop(1, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000003
      - next_table: 0
      - set ig_intr_md_for_dprsr.drop_ctl, 1
    default_action: Ingress.drop
stage 3 ingress:
  dependency: action
  ternary_match ipv4_lpm_0 0:
    p4: { name: Ingress.ipv4_lpm, size: 4 }
    p4_param_order: 
      hdr.ipv4.dstAddr: { type: lpm, size: 32, full_size: 32 }
    row: 0
    bus: 0
    column: 0
    input_xbar:
      ternary group 0: { 0: hdr.ipv4.dstAddr }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x55 }
    hit: [  END ]
    miss:  END
    indirect: ipv4_lpm_0$tind
  ternary_indirect ipv4_lpm_0$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 0: hdr.ipv4.dstAddr }
    format: { action: 0..0 }
    action: ipv4_lpm_0$action_data($DIRECT, $DEFAULT)
    instruction: ipv4_lpm_0$tind(action, $DEFAULT)
    actions:
      Ingress.ipv4_forward(0, 1):
      - p4_param_order: { dst_addr: 48, port: 9 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000004
      - next_table: 0
      - { port: $adf_h0(0..8), dst_addr_1.32-47: $adf_h1(0..15), dst_addr.32-47: dst_addr_1.32-47, dst_addr_1.0-31: $adf_f1(0..31), dst_addr.0-31: dst_addr_1.0-31 }
      - set hdr.ethernet.src_addr.0-31, hdr.ethernet.dst_addr.0-31
      - set hdr.ethernet.src_addr.32-47, hdr.ethernet.dst_addr.32-47
      - set hdr.ethernet.dst_addr.0-31, dst_addr.0-31
      - set hdr.ethernet.dst_addr.32-47, dst_addr.32-47
      - set ig_intr_md_for_tm.ucast_egress_port, port
      - add hdr.ipv4.ttl, hdr.ipv4.ttl, 255
      Ingress.drop(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000005
      - next_table: 0
      - {  }
      - set ig_intr_md_for_dprsr.drop_ctl, 1
    default_action: Ingress.drop
  action ipv4_lpm_0$action_data:
    p4: { name: Ingress.ipv4_lpm$action }
    row: 15
    logical_bus: A
    column: 0
    vpns: [ 0 ]
    home_row:
    - 15
    format Ingress.ipv4_forward: { $adf_h0: 0..15, $adf_h1: 16..31, $adf_f1: 32..63 }
    action_bus: { 32..33 : $adf_h0, 34..35 : $adf_h1, 100..103 : $adf_f1 }


primitives: "/home/nsg/p4-tools/p4-utils/examples/tofino/build/heavy_hitter/tofino/pipe//heavy_hitter.prim.json"
dynhash: "/home/nsg/p4-tools/p4-utils/examples/tofino/build/heavy_hitter/tofino/pipe//heavy_hitter.dynhash.json"
